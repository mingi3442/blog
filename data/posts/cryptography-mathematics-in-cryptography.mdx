---
title: 'μ•”νΈν•™μ„ μ„ν• μν•™μ  κΈ°λ° RSA μ•κ³ λ¦¬μ¦'
date: '2022-04-25'
lastmod: '2022-04-25'
tags: ['Cryptography']
draft: false
summary: 'μ ν΄λ¦¬λ“ μ•κ³ λ¦¬μ¦, μ¤μΌλ¬μ μ •λ¦¬, Trapdoor, One-way Functionμ™€ μ•”νΈν•™'
images: ['/static/images/thumbnail/cryptography.png']
canonicalUrl: 'https://min71.dev/posts/cryptography-mathematics-in-cryptography'
---

## Trapdoor

**_Trapdoor ν•¨μλ” μ‰½κ² κ³„μ‚°λμ§€λ§, νΉμ •ν• λΉ„λ°€ μ •λ³΄(Trapdoor) μ—†μ΄λ” μ—­μ‚°ν•κΈ° μ–΄λ ¤μ΄ ν•¨μμ…λ‹λ‹¤.
λΉ„λ€μΉ­ν‚¤ μ•”νΈν™”μ—μ„ κ³µκ°ν‚¤λ΅ λ°μ΄ν„°λ¥Ό μ•”νΈν™”ν•  μ μμ§€λ§, κ°μΈν‚¤ μ—†μ΄λ” λ³µνΈν™”ν•  μ μ—†λ” κµ¬μ΅°λ¥Ό μ κ³µν•©λ‹λ‹¤. μ΄λ” κ³µκ°ν‚¤ μ•”νΈν™” μ‹μ¤ν…μ κΈ°λ³Έμ μΈ κµ¬μ΅°λ΅, λ°μ΄ν„° λ³΄μ•κ³Ό ν‚¤ κ΄€λ¦¬μ— ν•µμ‹¬μ μΈ μ—­ν• μ„ ν•©λ‹λ‹¤._**

> Trapdoorκ°€ μ£Όμ–΄μ§€λ©΄ `fβ»ΒΉ(y)`λ¥Ό μ΄μ©ν•΄ `x`λ¥Ό κµ¬ν•  μ μμµλ‹λ‹¤.

> **k \* k' = 1 mod n** μ΄κ³ , **k** λ¥Ό μ• μ μλ‹¤λ©΄ **x = yαµ mod n** μ„ μ΄μ©ν•΄ x λ¥Ό κµ¬ν•  μ μμµλ‹λ‹¤.
>
>     β¤· **k** : κ³µκ° ν‚¤
>
>     β¤· **k'** : λΉ„κ³µκ° ν‚¤

---

## One-Way Function

**_One-way functionμ€ κ³„μ‚°μ€ μ‰½μ§€λ§ μ—­μ‚°μ΄ κ·Ήλ„λ΅ μ–΄λ ¤μ΄ ν•¨μμ΄λ©°, λ€ν‘μ μΈ μμ‹λ΅ ν•΄μ‹ν•¨μκ°€ μμµλ‹λ‹¤._**

**_λΉ„λ€μΉ­ν‚¤ μ•”νΈν™”μ—μ„ μ΄λ¬ν• ν•¨μλ“¤μ€ κ³µκ°ν‚¤λ΅ μ•”νΈν™”κ°€ κ°€λ¥ν•κ² ν•λ©°, μ¤μ§ ν•΄λ‹Ή κ°μΈν‚¤λ¥Ό κ°€μ§„ μ‚¬μ©μλ§μ΄ λ°μ΄ν„°λ¥Ό λ³µνΈν™”ν•  μ μλ„λ΅ ν•©λ‹λ‹¤. μ΄λ” λ³΄μ•μ„±μ΄ λ†’μ€ ν†µμ‹ κ³Ό λ°μ΄ν„° μ „μ†΅μ— ν•„μμ μΈ μ—­ν• μ„ ν•©λ‹λ‹¤._**

> **x**κ°€ μ£Όμ–΄μ§ κ²½μ° **f(x)** μ κ³„μ‚°μ€ μ‰½μ§€λ§, **y** κ°€ μ£Όμ–΄μ§€λ”λΌλ„ **fβ»ΒΉ(y)** λ¥Ό ν†µν•΄ xλ¥Ό κ³„μ‚°ν•λ”κ±΄ μ–΄λ µμµλ‹λ‹¤.

> **`y = xαµ mod n`** λ§μ•½ **n > x** μ΄κ³  **x** μ™€ **k** κ°€ μ£Όμ–΄μ§„λ‹¤λ©΄ κ³„μ‚°μ΄ μ‰½μ§€λ§,
>
> **y**, **n**, **k** λ¥Ό μ΄μ©ν•μ—¬ **x** λ¥Ό κ³„μ‚°ν•λ” κ²ƒμ€ μ–΄λ µμµλ‹λ‹¤.

---

## Euler's theorem

**_RSA μ•”νΈν™” κ³Όμ •μ—μ„ μ¤‘μ”ν• μ—­ν• μ„ ν•λ©° κ³µκ°ν‚¤μ™€ κ°μΈν‚¤μ μƒμ„± λ° λ³µνΈν™” κ³Όμ •μ—μ„ μ¤μΌλ¬μ μ •λ¦¬λ¥Ό μ‚¬μ©ν•μ—¬ μ•”νΈν™” λ° λ³µνΈν™” μ—°μ‚°μ΄ μν–‰λ©λ‹λ‹¤._**

### Ο†β’©

_**Z<sub>n</sub>** μ— μ†ν•κ³  **`n`** λ³΄λ‹¤ μ‘μΌλ©΄μ„ **`n`** κ³Ό μ„λ΅μ†μΈ μ •μμ κ°μ_

**Ο†β’© νΉμ§•**

> - **`Ο†(1)` = `0`**
> - *`p`κ°€ μ†μμΌ κ²½μ°*β€ƒβ®•β€ƒ **`Ο†(p)` = `p-1`**
> - *`p`κ°€ μ†μμΌ κ²½μ°*β€ƒβ®•β€ƒ **`Ο†(pαµ‰)` = `pαµ‰` - `pαµ‰β»ΒΉ`**
> - *`m`κ³Ό `n`μ΄ μ„λ΅μμΌ κ²½μ°*β€„β€„ β®•β€ƒ**`Ο†(m * n)` = `Ο†(m)` \* `Ο†(n)`**

**Ο†β’© μ¤μΌλ¬μ μ •λ¦¬**

> - *`a`κ³Ό `n`μ΄ μ„λ΅μμΌ κ²½μ°*β€„β€„ β®•β€ƒ**$a^{Ο†(n)} = 1β€ modβ€ n$**
> - *`a < n`μ΄κ³  `k`κ°€ μ •μμΌ κ²½μ°*β€„β€„ β®•β€ƒ**$a^{k Γ— Ο†(n)+1} = aβ€ modβ€ n$**

---

## Euclidean algorithm

**_λ‘ μ–‘μ μ •μ, νΉμ€ λ‘ λ‹¤ν•­μ‹μ μµλ€ κ³µμ•½μ(GCD)λ¥Ό κµ¬ν•λ” μ•κ³ λ¦¬μ¦μΌλ΅ λΉ„ λ€μΉ­ν‚¤ μ•”νΈν™”μ—μ„λ” ν‚¤ μƒμ„± κ³Όμ •μ— μ¤‘μ”ν• μ—­ν• μ„ ν•©λ‹λ‹¤. νΉν RSA μ•”νΈν™”μ—μ„λ” λ‘ ν° μ†μλ¥Ό μ„ νƒν•κ³ , κ·Έ κ³±μΌλ΅ κµ¬μ„±λ λ¨λ“λ¬μ¤μ—μ„ κ³µκ°ν‚¤μ™€ κ°μΈν‚¤λ¥Ό μƒμ„±ν•  λ• μ΄ μ•κ³ λ¦¬μ¦μ΄ μ‚¬μ©λ©λ‹λ‹¤._**

### Euclidean algorithm (μ ν΄λ¦¬λ“ μ•κ³ λ¦¬μ¦)

λ‘ μλ¥Ό λ°›μ•„ λ‚λ¨Έμ§€μ—°μ‚°μ„ ν•μ—¬ μµλ€ κ³µμ•½μλ¥Ό κµ¬ν•λ” μ•κ³ λ¦¬μ¦μΌλ΅ **`golang`** μ„ μ΄μ©ν•μ—¬ κµ¬ν„ν•λ©΄ λ‹¤μκ³Ό κ°™μµλ‹λ‹¤.

```go
func main() {
	var a, b int
	reader := bufio.NewReader(os.Stdin)
	fmt.Fscanf(reader, "%d %d", &a, &b)  // a,bλ¥Ό μ…λ ¥ λ°›λ”λ‹¤
	if a < b {
		a, b = b, a // λ‚λ¨Έμ§€ μ—°μ‚°μ„ ν•κΈ° μ„ν•΄ bκ°€ aλ³΄λ‹¤ ν΄ κ²½μ° μλ¦¬λ¥Ό λ°”κΏ”μ¤€λ‹¤
	}
	gcd := 0  // μµλ€κ³µμ•½μ μ„ μ–Έ
	for {
		r := a % b
		if r == 0 {
        	//λ‚λ¨Έμ§€ μ—°μ‚° κ°’μ΄ 0μΌ κ²½μ° μµλ€ κ³µμ•½μ κ°’μ€ 0μ΄ λλ©° λ°λ³µλ¬Έμ€ μΆ…λ£
			gcd = b
			break
		}
        // λ‚λ¨Έμ§€ μ—°μ‚° κ°’μ΄ 0μ΄ μ•„λ‹ κ²½μ°  aμ—λ” bλ¥Ό, bμ—λ” λ‚λ¨Έμ§€ μ—°μ‚° κ°’μ„ μ„ μ–Έν•΄μ„ λ°λ³µ
		a = b
		b = r
	}
	fmt.Println(gcd)
}

```

### π–¤ Extended Euclidean algorithm (ν™•μ¥ μ ν΄λ¦¬λ“ μ•κ³ λ¦¬μ¦)

RSAμ—μ„ Private Keyλ¥Ό κµ¬ν•κΈ° μ„ν•΄ μ‚¬μ©ν•λ©°
**`golang`** μ„ μ΄μ©ν•μ—¬ κµ¬ν„ν•λ©΄ λ‹¤μκ³Ό κ°™μµλ‹λ‹¤.

```go
func main() {
	var a, b int
	reader := bufio.NewReader(os.Stdin)
	fmt.Fscanf(reader, "%d %d", &a, &b)
	r1 := a
	r2 := b
	t1 := 0
	t2 := 1
	for r2 > 0 {
		q := r1 / r2
		r := r1 - q*r2
		r1, r2 = r2, r
		t := t1 - q*t2
		t1, t2 = t2, t
		r = a % b
		if r1 != 1 {
        	// if r1 != 1μΌ κ²½μ° a, bκ°€ μµλ€κ³µμ•½μκ°€ 1μ΄ μ•„λ‹λ―€λ΅, bμ inverseλ” μ΅΄μ¬ν•μ§€ μ•λ”λ‹¤
			fmt.Println(0)
		}
		if t1 < 0 {
        	// λ§μ•½ t1μ΄ μμκ°€ λλ©΄ "t1 % n" λλ” t1μ„ λ”ν•΄μ£Όμ–΄μ„ ν•΄κ²°ν•λ‹¤
			t1 = a + t1
		}
	}
	fmt.Println(t1)
}
```

### μ•”νΈν™”μ™€ λ³µνΈν™”

- **Encryption (μ•”νΈν™”)** : PlainText(P)μ™€ κ³µκ°ν‚¤ e, nμ„μ΄μ©ν•΄ $P^eβ€modβ€n$μ„ κ³„μ‚°

```
RSA_Encryption (P, e, n) {
	C = Fast_Exponentiation(P, e, n)
    retrun C
}
```

- **Decryption (λ³µνΈν™”)** : CipherText(C)μ™€ λΉ„κ³µκ°ν‚¤ d, nμ„μ΄μ©ν•΄ $C^dβ€modβ€n$μ„ κ³„μ‚°

```
RSA_Decryption (C, d, n) {
	P = Fast_Exponentiation(C, d, n)
    retrun P
}
```

### Fast_Exponentiation

$y= a^xβ€modβ€n$μ„ κ³„μ‚°ν•λ” κ³„μ‚° μ‹κ°„μ„ λ‹¨μ¶•ν•κΈ° μ„ν•΄ <u>**Square and Multiply**</u> κ°λ…μ„ μ΄μ©ν•΄μ„ κ³„μ‚°ν•λ” λ°©λ²•μ…λ‹λ‹¤.

> $y= a^9β€= a^{1001_2} = a^8 Γ— 1 Γ— 1 Γ— a$

μ„μ™€ κ°™μ€ μ‹μ„ `golang`μ **`rsa`** ν¨ν‚¤μ§€λ¥Ό μ΄μ©ν•μ—¬ κµ¬ν„ν•  μ μκ³ , ν¨ν‚¤μ§€ μ•μ μ½”λ“λ” μ•„λμ™€ κ°™μµλ‹λ‹¤.

```go
func SquareAndMultiply(base int, exp int, modulo int) int {
	res := base
	// converst the number to a string of 0 and 1 in binary
	bin := strconv.FormatInt(int64(exp), 2)
	for e := 1; e < len(bin); e++ {
		res *= res
		res %= modulo
		if bin[e] == '1' {
			res *= base
			res %= modulo
		}
	}
	return res
}

```

---
